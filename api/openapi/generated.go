// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// AnalyticsData defines model for AnalyticsData.
type AnalyticsData struct {
	ActiveUsersLast7Days     *int `json:"active_users_last_7_days,omitempty"`
	ContentsCreatedLast7Days *int `json:"contents_created_last_7_days,omitempty"`
	TotalContents            int  `json:"total_contents"`
	TotalUsers               int  `json:"total_users"`
}

// Content defines model for Content.
type Content struct {
	Body      string             `json:"body"`
	CreatedAt time.Time          `json:"created_at"`
	Id        openapi_types.UUID `json:"id"`
	Title     string             `json:"title"`
	UpdatedAt time.Time          `json:"updated_at"`
	UserId    openapi_types.UUID `json:"user_id"`
}

// CreateContentRequest defines model for CreateContentRequest.
type CreateContentRequest struct {
	Body  string `json:"body"`
	Title string `json:"title"`
}

// CreateUserRequest defines model for CreateUserRequest.
type CreateUserRequest struct {
	Email    openapi_types.Email `json:"email"`
	Name     string              `json:"name"`
	Password string              `json:"password"`
}

// Error defines model for Error.
type Error struct {
	Code    int    `json:"code"`
	Message string `json:"message"`
}

// LoginRequest defines model for LoginRequest.
type LoginRequest struct {
	Email    openapi_types.Email `json:"email"`
	Password string              `json:"password"`
}

// TokenResponse defines model for TokenResponse.
type TokenResponse struct {
	AccessToken  string  `json:"access_token"`
	ExpiresIn    int     `json:"expires_in"`
	RefreshToken *string `json:"refresh_token,omitempty"`
	TokenType    string  `json:"token_type"`
}

// User defines model for User.
type User struct {
	CreatedAt time.Time           `json:"created_at"`
	Email     openapi_types.Email `json:"email"`
	Id        openapi_types.UUID  `json:"id"`
	Name      string              `json:"name"`
	UpdatedAt time.Time           `json:"updated_at"`
}

// PostAuthLoginJSONRequestBody defines body for PostAuthLogin for application/json ContentType.
type PostAuthLoginJSONRequestBody = LoginRequest

// PostContentJSONRequestBody defines body for PostContent for application/json ContentType.
type PostContentJSONRequestBody = CreateContentRequest

// PostUsersJSONRequestBody defines body for PostUsers for application/json ContentType.
type PostUsersJSONRequestBody = CreateUserRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get analytics data
	// (GET /analytics)
	GetAnalytics(c *gin.Context)
	// User login
	// (POST /auth/login)
	PostAuthLogin(c *gin.Context)
	// Refresh access token
	// (POST /auth/refresh)
	PostAuthRefresh(c *gin.Context)
	// List all content
	// (GET /content)
	GetContent(c *gin.Context)
	// Create new content
	// (POST /content)
	PostContent(c *gin.Context)
	// Get content by ID
	// (GET /content/{contentId})
	GetContentContentId(c *gin.Context, contentId openapi_types.UUID)
	// List all users
	// (GET /users)
	GetUsers(c *gin.Context)
	// Create a new user
	// (POST /users)
	PostUsers(c *gin.Context)
	// Get user by ID
	// (GET /users/{userId})
	GetUsersUserId(c *gin.Context, userId openapi_types.UUID)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetAnalytics operation middleware
func (siw *ServerInterfaceWrapper) GetAnalytics(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetAnalytics(c)
}

// PostAuthLogin operation middleware
func (siw *ServerInterfaceWrapper) PostAuthLogin(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostAuthLogin(c)
}

// PostAuthRefresh operation middleware
func (siw *ServerInterfaceWrapper) PostAuthRefresh(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostAuthRefresh(c)
}

// GetContent operation middleware
func (siw *ServerInterfaceWrapper) GetContent(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetContent(c)
}

// PostContent operation middleware
func (siw *ServerInterfaceWrapper) PostContent(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostContent(c)
}

// GetContentContentId operation middleware
func (siw *ServerInterfaceWrapper) GetContentContentId(c *gin.Context) {

	var err error

	// ------------- Path parameter "contentId" -------------
	var contentId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "contentId", c.Param("contentId"), &contentId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter contentId: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetContentContentId(c, contentId)
}

// GetUsers operation middleware
func (siw *ServerInterfaceWrapper) GetUsers(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetUsers(c)
}

// PostUsers operation middleware
func (siw *ServerInterfaceWrapper) PostUsers(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostUsers(c)
}

// GetUsersUserId operation middleware
func (siw *ServerInterfaceWrapper) GetUsersUserId(c *gin.Context) {

	var err error

	// ------------- Path parameter "userId" -------------
	var userId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "userId", c.Param("userId"), &userId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter userId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetUsersUserId(c, userId)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/analytics", wrapper.GetAnalytics)
	router.POST(options.BaseURL+"/auth/login", wrapper.PostAuthLogin)
	router.POST(options.BaseURL+"/auth/refresh", wrapper.PostAuthRefresh)
	router.GET(options.BaseURL+"/content", wrapper.GetContent)
	router.POST(options.BaseURL+"/content", wrapper.PostContent)
	router.GET(options.BaseURL+"/content/:contentId", wrapper.GetContentContentId)
	router.GET(options.BaseURL+"/users", wrapper.GetUsers)
	router.POST(options.BaseURL+"/users", wrapper.PostUsers)
	router.GET(options.BaseURL+"/users/:userId", wrapper.GetUsersUserId)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/8xYXW/bNhT9K8TdHrXKXYNt0FvSboOHDAiyBsMQBAIjXtvsJFIlqbSeof8+kJRk0aG/",
	"Njvtk2XxkvfwHPLwUisoZFVLgcJoyFagiwVW1D1eClouDS/0O2qofVErWaMyHF0zLQx/wrzRqHReUm3y",
	"H3NGl67NLGuEDLgwOEcFbQKFFMbmyAuF1CDb38NIQ8u877crxkGIBbQJKPzYcIUMsvsg+tn4D0nfXT5+",
	"wMLY4d/6xudzf5RsOUqojeJi7qbZzY66TjOpKvsEjBr8zvAKIXneh7Mgtmk4i4UZbkqMJm1qdnRSy0J+",
	"UOYNEn2Iw5J4HtaDBfMPcEXZdbEdx7f4sUF9DNXb+NgUfQx1O4w7jWorBqwoLwOq/JsIr4JWcZFqqvUn",
	"qULGh5cJVFxco5ibBWQ/7dPAJUkGEMMosen9rJRUz6dUSOZw4mda1ZbHi8kkieywCrWm8zAUrigjqiNr",
	"H1aXaD1ODOK1nHNxCvL3cbwb6UF0vpd/o7hFXUuhMWaKBWqdGxsVXQb4ueYKdc5FQOmbH+L0K5wp1Isd",
	"A7qW3L8ea/SIVKHaO+kAcDBagDVGhd0ykYX1HxzwCIkPNMut2/B4r4z538YGPNz12gQ0Fo3iZvmHPWk9",
	"Z1dOq8vGbv5Vp9wvPbTf/nwPiT+XY7oujKmhtQNzMZO2P0NdKF4bLgVkcHkzJTOpyFI2itC6LnlBXdPg",
	"oPCXbbq8mUICT6i07/f61eTVxDImaxS05pDBG/fKbhCzcLhT2pcI9t8cHad2MbgMUwYZ/IpmqCPAMul3",
	"juvw/WTirWg4ZUf40g9ainVFYp++VTiDDL5J1yVL2tUraVisOD42eOgDCHMRCVxMXp8svXfZSNo7QRuz",
	"kIr/gyyQH7L7UPj7h/YhAd1UFVVLzxyhG6DbBFI7Xlpay3SbT+oI6zdSGzuqc1bwCxi1uerO0pNMOXDt",
	"NtwmRjXYnlHt0IUjtDtwRDfO3WZN+WJ6T8UTLTkjhUKGwnBaai/7oKu1TeL1W+vZ+fx+RW+7wC9Jrgsg",
	"HWS7rF+YW6mIP5oY8efWUfuqY5D4k280QjpCv83L+hvB/6SfG6z0Ph76XO3g9VQpuoyaGym5NkTOSA/h",
	"KEqubWdaluveyY5lOObg9LYSvRUcZC+nW4ED88+Z7ppId+T7tT85/9ofl9xHaev5JAI/BWujX+zpqnuY",
	"svaAhf+2D3ZlgKIVGnf3vl+BPY9cadDXRxkUo+hQvWTEx77758MZve4ApRkayq2LW6Uvzq90n1dIQ2ay",
	"EWzj/LB1QYeAPC7J9J3Xc/gIsk3Bu+67x/mNy10MjnItD/7rr8kGoxwAb7fJNd/nMsnxN4sXdkgvcYRa",
	"W9x8cW/cND/q7K/R3TdBv1fSlf3ZY3tOxDsXd5DjNX3o12l3O2V7aaNzSTdc7pjLkeV6cEDXWT310oSZ",
	"fqdc2Asu8SH2kq5KyCC199r2of03AAD//4Jpe4AFFwAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
